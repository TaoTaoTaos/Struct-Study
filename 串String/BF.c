// 题目要求：实现BF算法（Brute Force）算法，也叫朴素匹配算法。
// BF算法是一种在字符串中查找子串的简单方法，它不对输入的文本串和待匹配串进行预处理。

// 思路和算法原理：
// 1. 从左到右逐个检查文本串中的字符是否和待匹配串中的字符相同。
// 2. 如果相同，就继续比较下一个字符；如果不同，就从文本串的下一个字符开始重新比较。
// 3. 这个过程一直持续到找到匹配的子串或者已经检查了所有可能的位置。

#include <stdio.h>
#include <string.h>

// BF算法的实现
int BF(char *txt, char *pat)
{
    // 获取文本串和待匹配串的长度
    int m = strlen(txt);
    int n = strlen(pat);

    // 遍历文本串
    for (int i = 0; i <= m - n; i++)
    {
        int j;

        // 对于每个位置，检查待匹配串的字符
        for (j = 0; j < n; j++)
            if (txt[i + j] != pat[j]) // 如果字符不匹配，就跳出循环
                break;

        // 如果已经检查了所有待匹配串的字符，说明找到了匹配的子串
        if (j == n)
            return i;
    }

    // 如果没有找到匹配的子串，就返回-1
    return -1;
}

int main()
{
    // 测试BF算法
    char txt[] = "ABABDABACDABABCABAB";
    char pat[] = "ABABCABAB";
    int result = BF(txt, pat);
    printf("Pattern found at index %d\n", result);
    return 0;
}

// 题目所考察的知识点：
// 1. 字符串操作：BF算法需要对字符串进行基本的操作，如获取长度和访问特定位置的字符。
// 2. 循环结构：BF算法使用了嵌套的循环结构来遍历文本串和待匹配串。
// 3. 条件判断：BF算法需要判断文本串中的字符是否和待匹配串中的字符相同。

//! 关键问题：BF算法的时间复杂度是O(mn)，其中m和n分别是文本串和待匹配串的长度。当待匹配串的长度接近于文本串的长度时，BF算法的效率会非常低。因此，虽然BF算法实现简单，但在处理大规模数据时，可能需要考虑更高效的字符串匹配算法，如KMP算法等。
