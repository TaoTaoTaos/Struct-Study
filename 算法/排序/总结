冒泡排序（Bubble Sort）：
这是一种简单的排序算法，它重复地遍历要排序的列表，比较每对相邻的项，并在必要时交换它们。最糟糕的情况下，冒泡排序的时间复杂度是O(n²)。

选择排序（Selection Sort）：
这种算法将列表分为已排序部分和未排序部分，然后从未排序部分中选择最小（或最大）的元素，将其添加到已排序部分的末尾。最糟糕的情况下，选择排序的时间复杂度是O(n²)。

插入排序（Insertion Sort）：
这种算法也将列表分为已排序部分和未排序部分，然后从未排序部分中取出一个元素，将其插入到已排序部分的正确位置。最糟糕的情况下，插入排序的时间复杂度是O(n²)。

归并排序（Merge Sort）：
这是一种分而治之的算法，它将列表分为两半，对每一半进行排序，然后将它们合并成一个有序的列表。在所有情况下，归并排序的时间复杂度都是O(n log n)。

快速排序（Quick Sort）：
这也是一种分而治之的算法，它选择一个“基准”元素，然后将列表分为两部分：一部分包含所有小于基准的元素，另一部分包含所有大于或等于基准的元素。然后对这两部分进行递归排序。在平均情况下，快速排序的时间复杂度是O(n log n)，但在最糟糕的情况下，它的时间复杂度是O(n²)。

堆排序（Heap Sort）：
这种算法使用了一种称为堆的数据结构。首先，它将列表转换为一个最大堆，然后将堆的根节点（即最大的元素）与列表的最后一个元素交换，并从堆中删除它。然后，它重新将剩余的元素转换为最大堆，并重复这个过程，直到堆变为空。在所有情况下，堆排序的时间复杂度都是O(n log n)。

计数排序（Counting Sort）、基数排序（Radix Sort）和桶排序（Bucket Sort）：这些都是非比较排序算法，它们在某些情况下可以实现线性时间复杂度。