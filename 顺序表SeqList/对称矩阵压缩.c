// 题目要求：实现对称矩阵的压缩
// 思路和算法原理：
// 对于一个n*n的对称矩阵，我们只需要存储上三角或下三角的元素即可。
// 我们可以使用一维数组来存储这些元素，数组的长度为n*(n+1)/2。
// 对于矩阵中的元素a[i][j]，如果i>=j，则在数组中的位置为i*(i+1)/2+j。

#include <stdio.h>

// 压缩对称矩阵
void compressMatrix(int n, int a[][n], int b[]) {
    // 遍历矩阵的上三角部分
    for (int i = 0; i < n; i++) { // 遍历行
        for (int j = 0; j <= i; j++) { // 遍历列
            // 将元素存储到一维数组中
            b[i*(i+1)/2+j] = a[i][j];
        }
    }
}

int main() {
    // 定义一个3*3的对称矩阵
    int a[3][3] = {
        {1, 2, 3},
        {2, 4, 5},
        {3, 5, 6}
    };
    // 定义一个一维数组来存储压缩后的元素
    int b[6];
    // 压缩对称矩阵
    compressMatrix(3, a, b);
    // 输出压缩后的元素
    for (int i = 0; i < 6; i++) {
        printf("%d ", b[i]);
    }
    return 0;
}

// 总结：
// 本题考察了对称矩阵的压缩存储，是数据结构中线性表的应用。
// 关键问题：
//! 对于对称矩阵，我们只需要存储上三角或下三角的元素即可，这样可以节省存储空间。
//! 对于矩阵中的元素a[i][j]，如果i>=j，则在数组中的位置为i*(i+1)/2+j，这是根据等差数列求和公式得出的。
