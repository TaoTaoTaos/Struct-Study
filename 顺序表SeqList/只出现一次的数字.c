// 题目要求：使用异或运算找到数组中只出现一次的数字。

// 思路：我们可以使用异或运算的性质：任何数和0做异或运算，结果仍然是原来的数，任何数和其自身做异或运算，结果是0。因此，如果我们将所有的数进行异或运算，出现两次的数就会变成0，最后剩下的就是只出现一次的数。

#include <stdio.h>

// 使用异或运算找到数组中只出现一次的数字
int singleNumber(int *nums, int numsSize)
{
    int res = 0;
    for (int i = 0; i < numsSize; i++)
    {
        res ^= nums[i];
    }
    return res;
}

int main()
{
    int nums[] = {4, 1, 2, 1, 2};              // 输入的数组
    int numsSize = sizeof(nums) / sizeof(int); // 数组的长度
    int res = singleNumber(nums, numsSize);    // 调用函数找到只出现一次的数字
    printf("%d\n", res);                       // 打印结果
    return 0;
}

// 总结：这个题目考察的是异或运算的使用。通过异或运算，我们可以在一次遍历中找到数组中只出现一次的数字。关键在于理解异或运算的性质，即任何数和0做异或运算，结果仍然是原来的数，任何数和其自身做异或运算，结果是0。
// 时间复杂度：O(n)，其中n为数组的长度。我们需要遍历整个数组，因此时间复杂度为O(n)。
// 空间复杂度：O(1)。我们只使用了常数个额外的变量，因此空间复杂度为O(1)。
