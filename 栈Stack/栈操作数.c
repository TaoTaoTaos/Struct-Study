/*
题目要求：
设计一个算法，判断给定的栈操作序列是否合法。合法的定义是在一个空栈上进行一系列的入栈和出栈操作，使得每一个出栈操作都对应一个先前的入栈操作。

思路和算法原理：
我们可以使用一个计数器来模拟栈的操作。遇到入栈操作，计数器加1；遇到出栈操作，计数器减1。如果在任何时候计数器变为负数，那么这个操作序列就是非法的，因为这意味着有出栈操作没有对应的入栈操作。如果操作序列结束后计数器为0，那么这个操作序列就是合法的。

以下是具体的C语言实现：
*/

#include <stdio.h>
#include <string.h>

// 判断栈操作序列是否合法的函数
int isLegal(char *ops) {
    int counter = 0;  // 初始化计数器为0
    int n = strlen(ops);  // 获取操作序列的长度
    for (int i = 0; i < n; i++) {  // 遍历操作序列
        if (ops[i] == 'I') {  // 如果是入栈操作，计数器加1
            counter++;
        } else if (ops[i] == 'O') {  // 如果是出栈操作，计数器减1
            counter--;
            if (counter < 0) {  // 如果计数器变为负数，返回0表示非法
                return 0;
            }
        }
    }
    return counter == 0;  // 如果计数器为0，返回1表示合法，否则返回0表示非法
}

int main() {
    char ops[] = "IIOIOIO";  // 测试的操作序列
    int result = isLegal(ops);  // 调用函数判断操作序列是否合法
    printf("%s\n", result ? "合法" : "非法");  // 输出结果
    return 0;
}

//总结：
//这个题目考察的是栈的基本操作和性质。栈是一种后进先出（LIFO）的数据结构，每一个出栈操作都必须对应一个先前的入栈操作。通过模拟栈的操作，我们可以判断一个操作序列是否合法。

//关键问题：
//! 1. 如何模拟栈的操作？
//我们可以使用一个计数器来模拟栈的操作。遇到入栈操作，计数器加1；遇到出栈操作，计器/减1。这样，计数器的值就等于当前栈中元素的数量。

//! 2. 如何判断操作序列是否合法？
//如果在任何时候计数器变为负数，那么这个操作序列就是非法的，因为这意味着有出栈操作没有对应的入栈操作。如果操作序列结束后计数器为0，那么这个操作序列就是合法的。

