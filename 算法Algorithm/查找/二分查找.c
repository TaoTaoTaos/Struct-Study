// 题目要求：实现二分查找的算法

// 思路：
//! 1. 首先，假设目标数组是有序的（如果不是，需要先进行排序）。
//  2. 然后，取数组的中间元素与目标值进行比较。
//  3. 如果目标值等于中间元素，那么查找成功，返回中间元素的索引。
// 4. 如果目标值小于中间元素，那么在数组的左半部分（即中间元素左边的部分）继续进行二分查找。
// 5. 如果目标值大于中间元素，那么在数组的右半部分（即中间元素右边的部分）继续进行二分查找。
// 6. 如果数组中没有目标值，那么查找失败，返回-1。

#include <stdio.h>

// 二分查找函数，参数为目标数组、数组长度和目标值
int binarySearch(int arr[], int len, int target)
{
    

    int left = 0, right = len - 1; //!   先同时指向最左和最右

    // 当左边界小于等于右边界时，继续查找
    while (left <= right) 
    {
        // 计算中间位置
        int mid = left + (right - left) / 2 ;

        // 如果找到目标值，返回索引
        if (arr[mid] == target)
        {
            return mid;
        }
        //!如果目标值小于中间元素，查找左半部分
        //!查找左半部分，相当于把 right 移动到 mid - 1
        else if (arr[mid] > target)
        {
            right = mid - 1;
        }

        //! 如果目标值大于中间元素，查找右半部分
        //!查找右半部分，相当于把 left 移动到 mid + 1
        else
        {
            left = mid + 1;
        }
        //! 当左边界大于等于右边界时，查找失败 
    }

    // 如果没有找到，返回-1
    return -1;
}

int main()
{
    // 测试数组
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
     
    // 数组长度

    int len = sizeof(arr) / sizeof(arr[0]);
    // 目标值
    int target = 5;

    // 调用二分查找函数
    int index = binarySearch(arr, len, target);

    // 打印结果
    if (index != -1)
    {
        printf("找到目标值%d，索引为%d\n", target, index);
    }
    else
    {
        printf("未找到目标值%d\n", target);
    }

    return 0;

}

// 总结：
// 本题考察的是二分查找算法的实现。二分查找是一种高效的查找算法，它的基本思想是将查找的问题规模不断减半，从而达到快速查找的目的。
// 本题的关键是理解二分查找的基本思想，并能够正确地在代码中实现这一思想。
// 1. 二分查找的时间复杂度为O(logn)，其中n为数组的长度。这是因为每进行一次查找，问题的规模就会减半。
// 2. 二分查找要求数组是有序的，这是它与顺序查找的一个重要区别。
// 3. 在实现二分查找的代码时，需要注意边界条件的处理，例如当目标值不在数组中时，应返回一个特殊的值（如-1）来表示查找失败。
// 4. 二分查找的实现中，计算中间位置时，使用“left + (right - left) / 2”而不是“(left + right) / 2”，是为了防止整数溢出。
