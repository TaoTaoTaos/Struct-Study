// 题目要求：实现图的基本操作

// 思路和算法原理：
// 图的基本操作包括创建图、添加顶点、添加边、删除顶点、删除边、遍历图等。
// 这里我们使用邻接矩阵来表示图，对于无向图，邻接矩阵是对称的；对于有向图，则不一定对称。
// 我们首先定义一个图的结构体，包含顶点数组和邻接矩阵。
// 然后实现创建图、添加顶点、添加边的函数。由于删除顶点和边的操作比较复杂，这里就不展开了。

#include <stdio.h>
#define MAXVEX 100  // 最大顶点数

// 定义图的结构体
typedef struct
{
    int vexs[MAXVEX];  // 顶点表
    int arc[MAXVEX][MAXVEX];  // 邻接矩阵
    int numVertexes, numEdges;  // 图中当前的顶点数和边数
} MGraph;

// 创建图
void CreateMGraph(MGraph *G)
{
    // 输入顶点数和边数
    printf("输入顶点数和边数:\n");
    scanf("%d,%d", &G->numVertexes, &G->numEdges);

    // 读入顶点信息
    for (int i = 0; i < G->numVertexes; i++)
        scanf("%d", &G->vexs[i]);

    // 初始化邻接矩阵
    for (int i = 0; i < G->numVertexes; i++)
    {
        for (int j = 0; j < G->numVertexes; j++)
        {
            if (i == j)
                G->arc[i][j] = 0;  // 对角线为0
            else
                G->arc[i][j] = 32767;  // 其他为无穷大
        }
    }

    // 读入numEdges条边，建立邻接矩阵
    for (int k = 0; k < G->numEdges; k++)
    {
        int i, j, w;
        printf("输入边(vi,vj)上的下标i，下标j和权w:\n");
        scanf("%d,%d,%d", &i, &j, &w);  // 输入边(vi,vj)上的权w
        G->arc[i][j] = w;
        G->arc[j][i] = G->arc[i][j];  // 因为是无向图，矩阵对称
    }
}

int main()
{
    MGraph G;
    CreateMGraph(&G);
    return 0;
}

// 总结：
// 本题考察了图的基本操作和邻接矩阵的使用。
// 图是一种非线性数据结构，它可以表示多对多的关系。
// 邻接矩阵是表示图的一种方法，它可以直观地看出任意两个顶点之间是否存在边。
// 通过邻接矩阵，我们可以方便地实现图的各种操作。

//! 关键问题：
//! 1. 如何表示图？
//!    图可以通过邻接矩阵或邻接表来表示。邻接矩阵易于理解和实现，但是对于稀疏图会浪费很多空间。邻接表则更加节省空间，但是实现起来较复杂。
//! 2. 如何添加和删除顶点和边？
//!    对于邻接矩阵，添加和删除边比较简单，只需要修改对应的矩阵元素即可。但是添加和删除顶点则比较复杂，需要重新调整矩阵的大小。
//!    对于邻接表，添加顶点和边都比较简单，只需要修改链表即可。但是删除顶点和边则需要遍历整个链表，时间复杂度较高。
